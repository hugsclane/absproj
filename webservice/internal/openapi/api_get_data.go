/*
ABS Data API (Beta)

<div>   <h2>About the Beta</h2>   <p>This beta release allows you to preview ABS Data API before it is released in its final form and gives you the opportunity to provide the ABS with feedback as we work to enhance the service.</p>   <p>We will continue to load new datasets and update existing datasets as soon as possible after embargo on the data is lifted. However, <b>data in this beta release may not necessarily be the most up to date.</b> For the most up to date information visit the <a href=\"https://www.abs.gov.au/\">ABS website</a>.</p>   <p>Availability of the ABS Data API (Beta) is not guaranteed. The service may be subject to change.</p>   <p>You can contact the ABS APIs team at <a href=\"mailto:api.data@abs.gov.au\">api.data@abs.gov.au</a>. Please let us know any feedback or issues you have. You can request to join our register of interest to be notified of any changes in the API.  The <a href=\"https://www.abs.gov.au/websitedbs/D3310114.nsf/Home/Privacy?opendocument#from-banner=GB\" target=\"_blank\">ABS privacy policy</a> outlines how the ABS handles any personal information that you provide to us.</p> </div> <div>   <h2>Key Information</h2>   <p>The ABS Data REST API allows you to request ABS statistics including detailed economic, social and Census data.  Filter your query to return the data and metadata you are interested in.</p>   <p>The ABS Data API uses the Statistical Data and Metadata Exchange (SDMX) standard.  Data is available in XML, JSON and CSV.</p> </div> 

API version: 0.2.0
Contact: api.data@abs.gov.au
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GetDataAPIService GetDataAPI service
type GetDataAPIService service

type ApiGetDataRequest struct {
	ctx context.Context
	ApiService *GetDataAPIService
	dataflowIdentifier string
	dataKey string
	startPeriod *string
	endPeriod *string
	format *string
	detail *string
	dimensionAtObservation *string
}

// The start period (used to filter on time). This is inclusive. The value can be in the following formats:   * year: yyyy * year-semester: yyyy-S1 - yyyy-S2 * year-quarter: yyyy-Q1 - yyyy-Q4   * year-month: yyyy-01 - yyyy-12 
func (r ApiGetDataRequest) StartPeriod(startPeriod string) ApiGetDataRequest {
	r.startPeriod = &startPeriod
	return r
}

// The end period (used to filter on time). This is inclusive. The value can be in the following formats: * year: yyyy * year-semester: yyyy-S1 - yyyy-S2   * year-quarter: yyyy-Q1 - yyyy-Q4   * year-month: yyyy-01 - yyyy-12 
func (r ApiGetDataRequest) EndPeriod(endPeriod string) ApiGetDataRequest {
	r.endPeriod = &endPeriod
	return r
}

// The format of data to return. Refer to the accept header if omitted.   * **csvwithlabels**: csv format with columns for dimension codes and labels. * **csvfile**: csv format with columns for dimension codes. * **jsondata**: sdmx json format equivalent to application/vnd.sdmx.data+json * **genericdata**: sdmx xml format equivalent to application/vnd.sdmx.genericdata+xml * **structurespecificdata**: sdmx xml format equivalent to application/vnd.sdmx.structurespecificdata+xml 
func (r ApiGetDataRequest) Format(format string) ApiGetDataRequest {
	r.format = &format
	return r
}

// The detail of data to return.  * **full**: The data - series and observations - and the attributes will be returned. This is the default. * **dataonly**: The attributes will be excluded from the returned message. * **serieskeysonly**: Only the series, but without the attributes and the observations, will be returned. This can be useful for performance reasons, to return the series that match a certain query, without returning the actual data. * **nodata**: The series, including the attributes, will be returned, but the observations will not be returned. 
func (r ApiGetDataRequest) Detail(detail string) ApiGetDataRequest {
	r.detail = &detail
	return r
}

// Define the way data should be organized in the returned message. Possible options are:  * **TIME_PERIOD**: This will return a timeseries view of the data. This is the default value. * **AllDimensions**: This will return a flat view of the data, with no groupings. * **The ID of any other dimension**: This will return a cross-sectional view of the data. 
func (r ApiGetDataRequest) DimensionAtObservation(dimensionAtObservation string) ApiGetDataRequest {
	r.dimensionAtObservation = &dimensionAtObservation
	return r
}

func (r ApiGetDataRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetDataExecute(r)
}

/*
GetData Get data from a dataflow in XML, JSON or CSV.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataflowIdentifier The dataflow identifier in {agencyId},{dataflowId},{version} format (eg. \"ABS,CPI,1.1.0\").  A list of all available dataflows can be returned using the *GET /rest/{structureType}/{agencyId}* operation. agencyId and version are optional. If agencyId is not specified it will default to “all”. If version is not specified it will default to “latest”. 
 @param dataKey The key to query data returned. Use \"all\" if you would like to return all data for the dataset. To filter data returned provide a data key, containing one or more coded values for each dimension, separated by a dot (dimensions must be in the order they are defined in the data structure).  For example “1.115486.10.50.Q”  filters for a single Consumer Price Index series  * *Measure*: 1 - Index Number * *Index*: 115486 - Health * *Adjustment Type*: 10 - Original * *Region*: 50 - Weighted average of eight capital cities * *Frequency*: Q - Quarterly   Wildcarding is supported by omitting values for the dimension. Eg. data for all regions: “1.115486.10..Q”. The OR operator is supported using the + character. Eg. data for 2 series “1.131188+131189.10.50.Q”.  You can combine wildcarding and the OR operator. Eg. “1.131188+131189.10..Q\".    The maximum allowed length of this parameter is currently 260 characters. Requests that exceed this limit will return a 400 error. We intend to increase this limit soon.  The dataKey parameter is case sensitive. 
 @return ApiGetDataRequest
*/
func (a *GetDataAPIService) GetData(ctx context.Context, dataflowIdentifier string, dataKey string) ApiGetDataRequest {
	return ApiGetDataRequest{
		ApiService: a,
		ctx: ctx,
		dataflowIdentifier: dataflowIdentifier,
		dataKey: dataKey,
	}
}

// Execute executes the request
//  @return string
func (a *GetDataAPIService) GetDataExecute(r ApiGetDataRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GetDataAPIService.GetData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/data/{dataflowIdentifier}/{dataKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataflowIdentifier"+"}", url.PathEscape(parameterValueToString(r.dataflowIdentifier, "dataflowIdentifier")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataKey"+"}", url.PathEscape(parameterValueToString(r.dataKey, "dataKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startPeriod", r.startPeriod, "", "")
	}
	if r.endPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endPeriod", r.endPeriod, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.detail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detail", r.detail, "", "")
	}
	if r.dimensionAtObservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dimensionAtObservation", r.dimensionAtObservation, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.sdmx.data+json", "application/xml", "application/vnd.sdmx.structurespecificdata+xml", "text/csv", "application/vnd.sdmx.data+csv", "application/vnd.sdmx.data+csv;labels=both", "application/vnd.sdmx.data+csv;file=true;labels=both"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
