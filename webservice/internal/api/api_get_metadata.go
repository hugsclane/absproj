/*
ABS Data API (Beta)

<div>   <h2>About the Beta</h2>   <p>This beta release allows you to preview ABS Data API before it is released in its final form and gives you the opportunity to provide the ABS with feedback as we work to enhance the service.</p>   <p>We will continue to load new datasets and update existing datasets as soon as possible after embargo on the data is lifted. However, <b>data in this beta release may not necessarily be the most up to date.</b> For the most up to date information visit the <a href=\"https://www.abs.gov.au/\">ABS website</a>.</p>   <p>Availability of the ABS Data API (Beta) is not guaranteed. The service may be subject to change.</p>   <p>You can contact the ABS APIs team at <a href=\"mailto:api.data@abs.gov.au\">api.data@abs.gov.au</a>. Please let us know any feedback or issues you have. You can request to join our register of interest to be notified of any changes in the API.  The <a href=\"https://www.abs.gov.au/websitedbs/D3310114.nsf/Home/Privacy?opendocument#from-banner=GB\" target=\"_blank\">ABS privacy policy</a> outlines how the ABS handles any personal information that you provide to us.</p> </div> <div>   <h2>Key Information</h2>   <p>The ABS Data REST API allows you to request ABS statistics including detailed economic, social and Census data.  Filter your query to return the data and metadata you are interested in.</p>   <p>The ABS Data API uses the Statistical Data and Metadata Exchange (SDMX) standard.  Data is available in XML, JSON and CSV.</p> </div> 

API version: 0.2.0
Contact: api.data@abs.gov.au
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GetMetadataAPIService GetMetadataAPI service
type GetMetadataAPIService service

type ApiGetLatestStructureRequest struct {
	ctx context.Context
	ApiService *GetMetadataAPIService
	structureType string
	agencyId string
	structureId string
	references *string
	detail *string
}

// Instruct the web service to return (or not) the artefacts referenced by the artefact(s) you are querying. Eg. the codelists and concepts used by the data structure you are querying. You can also retrieve the artefacts that use the artefact you are querying, eg. the dataflows that use the data structure definition queried.  * **none**: No references will be returned. This is the default. * **parents**: The artefacts that use the artefact matching the query (for example, the dataflows that use the data structure definition matching the query) will be returned. * **parentsandsiblings**: The artefacts that use the artefact matching the query, as well as the artefacts referenced by these artefacts will be returned. * **children**: The artefacts referenced by the matching artefact will be returned (for example, the concept schemes and code lists used in a DSD). * **descendants**: References of references, up to any level, will also be returned. * **all**: The combination of parentsandsiblings and descendants. * In addition, a specific structure type may also be used (e.g. codelist, dataflow, etc.). 
func (r ApiGetLatestStructureRequest) References(references string) ApiGetLatestStructureRequest {
	r.references = &references
	return r
}

// Specify the desired amount of detail to be returned. For example, it is possible to instruct the web service to return only basic information about the resource, this is known in SDMX as a stub.  * **allstubs**: All artefacts will be returned as stubs. * **referencestubs**: The referenced artefacts will be returned as stubs. * **referencepartial**: The referenced item schemes should only include items used by the artefact to be returned. For example, a concept scheme would only contain the concepts used in a DSD, and its isPartial flag would be set to true. As another example, if a dataflow is constrained, then the codelists returned should only contain the subset of codes allowed by that constraint. * **allcompletestubs**: All artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **referencecompletestubs**: The referenced artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **full**: All available information for all artefacts will be returned. This is the default. 
func (r ApiGetLatestStructureRequest) Detail(detail string) ApiGetLatestStructureRequest {
	r.detail = &detail
	return r
}

func (r ApiGetLatestStructureRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetLatestStructureExecute(r)
}

/*
GetLatestStructure Get the latest structure of a specific type, for a given agency and structure id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param structureType The type of structure to retrieve.
 @param agencyId The id of the agency maintaining the structures. Eg. \"ABS\".
 @param structureId The structure's id. \"all\" will return all artefacts of the selected structure type.
 @return ApiGetLatestStructureRequest
*/
func (a *GetMetadataAPIService) GetLatestStructure(ctx context.Context, structureType string, agencyId string, structureId string) ApiGetLatestStructureRequest {
	return ApiGetLatestStructureRequest{
		ApiService: a,
		ctx: ctx,
		structureType: structureType,
		agencyId: agencyId,
		structureId: structureId,
	}
}

// Execute executes the request
//  @return string
func (a *GetMetadataAPIService) GetLatestStructureExecute(r ApiGetLatestStructureRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GetMetadataAPIService.GetLatestStructure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/{structureType}/{agencyId}/{structureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"structureType"+"}", url.PathEscape(parameterValueToString(r.structureType, "structureType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agencyId"+"}", url.PathEscape(parameterValueToString(r.agencyId, "agencyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"structureId"+"}", url.PathEscape(parameterValueToString(r.structureId, "structureId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "", "")
	}
	if r.detail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detail", r.detail, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "application/vnd.sdmx.structure+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStructuresRequest struct {
	ctx context.Context
	ApiService *GetMetadataAPIService
	structureType string
	agencyId string
	structureId string
	structureVersion string
	references *string
	detail *string
}

// Instruct the web service to return (or not) the artefacts referenced by the artefact(s) you are querying. Eg. the codelists and concepts used by the data structure you are querying. You can also retrieve the artefacts that use the artefact you are querying, eg. the dataflows that use the data structure definition queried.  * **none**: No references will be returned. This is the default. * **parents**: The artefacts that use the artefact matching the query (for example, the dataflows that use the data structure definition matching the query) will be returned. * **parentsandsiblings**: The artefacts that use the artefact matching the query, as well as the artefacts referenced by these artefacts will be returned. * **children**: The artefacts referenced by the matching artefact will be returned (for example, the concept schemes and code lists used in a DSD). * **descendants**: References of references, up to any level, will also be returned. * **all**: The combination of parentsandsiblings and descendants. * In addition, a specific structure type may also be used (e.g. codelist, dataflow, etc.). 
func (r ApiGetStructuresRequest) References(references string) ApiGetStructuresRequest {
	r.references = &references
	return r
}

// Specify the desired amount of detail to be returned. For example, it is possible to instruct the web service to return only basic information about the resource, this is known in SDMX as a stub.  * **allstubs**: All artefacts will be returned as stubs. * **referencestubs**: The referenced artefacts will be returned as stubs. * **referencepartial**: The referenced item schemes should only include items used by the artefact to be returned. For example, a concept scheme would only contain the concepts used in a DSD, and its isPartial flag would be set to true. As another example, if a dataflow is constrained, then the codelists returned should only contain the subset of codes allowed by that constraint. * **allcompletestubs**: All artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **referencecompletestubs**: The referenced artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **full**: All available information for all artefacts will be returned. This is the default. 
func (r ApiGetStructuresRequest) Detail(detail string) ApiGetStructuresRequest {
	r.detail = &detail
	return r
}

func (r ApiGetStructuresRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetStructuresExecute(r)
}

/*
GetStructures Get a specific version of a structure of a specific type, for a given agency and structure id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param structureType The type of structure to retrieve.
 @param agencyId The id of the agency maintaining the structures. Eg. \"ABS\".
 @param structureId The structure's id. \"all\" will return all artefacts of the selected structure type.
 @param structureVersion The version of the structure to retrieve. Three numbers separated by points, eg. \"1.0.0\".
 @return ApiGetStructuresRequest
*/
func (a *GetMetadataAPIService) GetStructures(ctx context.Context, structureType string, agencyId string, structureId string, structureVersion string) ApiGetStructuresRequest {
	return ApiGetStructuresRequest{
		ApiService: a,
		ctx: ctx,
		structureType: structureType,
		agencyId: agencyId,
		structureId: structureId,
		structureVersion: structureVersion,
	}
}

// Execute executes the request
//  @return string
func (a *GetMetadataAPIService) GetStructuresExecute(r ApiGetStructuresRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GetMetadataAPIService.GetStructures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/{structureType}/{agencyId}/{structureId}/{structureVersion}"
	localVarPath = strings.Replace(localVarPath, "{"+"structureType"+"}", url.PathEscape(parameterValueToString(r.structureType, "structureType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agencyId"+"}", url.PathEscape(parameterValueToString(r.agencyId, "agencyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"structureId"+"}", url.PathEscape(parameterValueToString(r.structureId, "structureId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"structureVersion"+"}", url.PathEscape(parameterValueToString(r.structureVersion, "structureVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "", "")
	}
	if r.detail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detail", r.detail, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "application/vnd.sdmx.structure+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStructuresByAgencyIdRequest struct {
	ctx context.Context
	ApiService *GetMetadataAPIService
	structureType string
	agencyId string
	detail *string
}

// Specify the desired amount of detail to be returned. For example, it is possible to instruct the web service to return only basic information about the resource, this is known in SDMX as a stub.  * **allstubs**: All artefacts will be returned as stubs. * **referencestubs**: The referenced artefacts will be returned as stubs. * **referencepartial**: The referenced item schemes should only include items used by the artefact to be returned. For example, a concept scheme would only contain the concepts used in a DSD, and its isPartial flag would be set to true. As another example, if a dataflow is constrained, then the codelists returned should only contain the subset of codes allowed by that constraint. * **allcompletestubs**: All artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **referencecompletestubs**: The referenced artefacts should be returned as complete stubs, containing identification information, the artefacts&#39; name, description, annotations and isFinal information. * **full**: All available information for all artefacts will be returned. This is the default. 
func (r ApiGetStructuresByAgencyIdRequest) Detail(detail string) ApiGetStructuresByAgencyIdRequest {
	r.detail = &detail
	return r
}

func (r ApiGetStructuresByAgencyIdRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetStructuresByAgencyIdExecute(r)
}

/*
GetStructuresByAgencyId Get all structures of a specific type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param structureType The type of structure to retrieve.
 @param agencyId The id of the agency maintaining the structures. Eg. \"ABS\".
 @return ApiGetStructuresByAgencyIdRequest
*/
func (a *GetMetadataAPIService) GetStructuresByAgencyId(ctx context.Context, structureType string, agencyId string) ApiGetStructuresByAgencyIdRequest {
	return ApiGetStructuresByAgencyIdRequest{
		ApiService: a,
		ctx: ctx,
		structureType: structureType,
		agencyId: agencyId,
	}
}

// Execute executes the request
//  @return string
func (a *GetMetadataAPIService) GetStructuresByAgencyIdExecute(r ApiGetStructuresByAgencyIdRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GetMetadataAPIService.GetStructuresByAgencyId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/{structureType}/{agencyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"structureType"+"}", url.PathEscape(parameterValueToString(r.structureType, "structureType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"agencyId"+"}", url.PathEscape(parameterValueToString(r.agencyId, "agencyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.detail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detail", r.detail, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/xml", "application/vnd.sdmx.structure+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
